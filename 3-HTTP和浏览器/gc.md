见： 设计模式/03-闭包/3.1.6-闭包与内存管理.md
https://github.com/yacan8/blog/issues/33






## 分代垃圾回收机制


堆空间分为两部分，一个小的**新生区**约1-8M 和一个大的**老生区**;

<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/357189121dda46368c4200eeb481c957~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?"/>


## 新生区

新生区采用`Scavenge`算法实现: Scavenge是一种空间换时间的算法，将新生区分为 `From区-激活区` 和 `To区-未激活区`两个区域，新增加的对象都放在 `From区` ，`From区` 快满的时候，会执行一次垃圾清理，执行过程：
  1. 先给  `From区` 所有垃圾做标记;
  2. 标记完成后，存活的对象被复制到 `To区`，并且将他们有序的排列一遍
  3. 然后将 `from区` 中的非活动对象的内存进行释放；
  4. 完成后，将 `from区` 和 `to区` 进行互换，

这样可以使新生区中的这两块区域可以重复利用。




## 老生区

老生区：采用 `标记清除` 和 `标记整理` 算法：

- 标记阶段：对老生区进行第一次扫描，标记活动对象；
- 清理阶段：对老生区进行第二次扫描，清除未被标记的对象;
- 标记整理：将所有的活动对象往一端移动，移动完成后，直接清理掉边界外的内存；




## 垃圾回收器是怎么知道哪些对象是活动对象和非活动对象的呢？

可达性，表示从初始的根对象（window，global）的指针开始，这个根指针对象被称为根集（root set），从这个根集向下搜索其子节点，被搜索到的子节点说明该节点的引用对象可达，并为其留下标记，然后递归这个搜索的过程，直到所有子节点都被遍历结束，那么没有被标记的对象节点，说明该对象没有被任何地方引用，可以证明这是一个需要被释放内存的对象，可以被垃圾回收器回收。


## 什么时候新生代晋升打老生代？

下一次垃圾回收，如果这个对象还在新生代中，副垃圾回收器会将该对象移动到老生代中，这个移动的过程被称为晋升。


## 全停顿 Stop-The-World


由于垃圾回收是在JS引擎中进行的，而Mark-Compact算法在执行过程中需要移动对象，而当活动对象较多的时候，它的执行速度不可能很快，为了避免JavaScript应用逻辑和垃圾回收器的内存资源竞争导致的不一致性问题，垃圾回收器会将JavaScript应用暂停，这个过程，被称为全停顿（stop-the-world）。

在新生代中，由于空间小、存活对象较少、Scavenge算法执行效率较快，所以全停顿的影响并不大。而老生代中就不一样，如果老生代中的活动对象较多，垃圾回收器就会暂停主线程较长的时间，使得页面变得卡顿。

## 优化

它利用了增量标记、懒性清理、并发、并行来降低主线程挂起的时间。

## 文章

- [深入理解谷歌最强V8垃圾回收机制](https://cloud.tencent.com/developer/article/1710084)
