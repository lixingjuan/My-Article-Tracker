<html><body><h1 id="7-种实现继承的方式">7 种实现继承的方式</h1>
<h2 id="1-原型链继承">1. 原型链继承</h2>
<p><strong>实现方式</strong>：将子类构造函数的 prototype 指向父类实例</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>子类的实例无法向父类传参</li>
<li>父类的引用类型值，子类和父类的所有实例都会共享</li>
</ol>
<pre><code class="language-js">function Animal(category) {
  this.category = category;
  this.colors = [&quot;pink&quot;, &quot;green&quot;];
}
Animal.prototype.speak = function () {
  console.log(&quot;I am &quot; + this.category);
};

function Dog(name) {
  this.name = name;
}
Dog.ptototype = new Animal();
Dog.ptototype.bark = function () {
  console.log(&quot;Woof!&quot;);
};
const dog1 = new Dog(&quot;Max&quot;);
dog1.speak();
dog1.bark();
</code></pre>
<h2 id="2-借用构造函数继承">2. 借用构造函数继承</h2>
<p><strong>实现方式</strong>：通过在子类中调用父类构造函数，解决原型链继承的两个缺点 1.不能向父类传参
<strong>缺点</strong>：只能继承属性，不能继承方法</p>
<pre><code class="language-js">function Animal(category) {
  this.category = category;
  this.colors = [&quot;pink&quot;, &quot;green&quot;];
}
Animal.prototype.speak = function () {
  console.log(&quot;I am &quot; + this.category);
};

function Dog(name) {
  Animal.call(this, &quot;Dog&quot;);
  this.name = name;
}
const dog1 = new Dog(&quot;Max&quot;);
dog1.speak();
dog1.bark();
</code></pre>
<h2 id="3-组合继承（伪经典继承）">3. 组合继承（伪经典继承）</h2>
<p><strong>实现方式</strong>：利用<strong>原型链继承</strong>继承方法，利用<strong>构造函数继承</strong>继承属性
<strong>缺点</strong>：父类构造函数会被调用两次：1.为子类指定 prototype 的时候；2.创建子类实例的时候</p>
<pre><code class="language-js">function Animal(category) {
  this.category = category;
  this.colors = [&quot;pink&quot;, &quot;green&quot;];
}
Animal.prototype.speak = function () {
  console.log(&quot;I am &quot; + this.category);
};

function Dog(name) {
  Animal.call(this, &quot;Dog&quot;);
  this.name = name;
}
Dog.prototype = new Animal();

const dog1 = new Dog(&quot;Max&quot;);
</code></pre>
<h2 id="4-原型式继承">4. 原型式继承</h2>
<p><strong>实现方式</strong>：利用 Object.create 以父类 prototype 为原型创建对象，赋值给子类的 prototype
缺点：无法向父类传参</p>
<pre><code class="language-js">function Animal(category) {
  this.category = category;
  this.colors = [&quot;pink&quot;, &quot;green&quot;];
}
function Dog(name) {
  this.name = name;
}

Dog.ptototype = Object.create(Animal.prototype);
</code></pre>
<h2 id="5-寄生式继承">5. 寄生式继承</h2>
<p><strong>实现方式</strong>:，利用 Object.create 在子类内部完成对父类的继承 和 增强
<strong>缺点</strong>：无法向父类传参数</p>
<pre><code class="language-js">function Animal(category) {
  this.category = category;
  this.colors = [&quot;pink&quot;, &quot;green&quot;];
}
function Dog(name) {
  return Object.create(Animal.prototype, {
    color: {
      value: [&quot;pink&quot;, &quot;black&quot;],
      enumerable: true,
      writable: true,
      configurable: true,
    },
    bark: {
      value: function () {},
    },
  });
}
</code></pre>
<h2 id="6-组合寄生式继承">6. 组合寄生式继承</h2>
<p>实现方式：在子类指定父类构造函数，完成属性的继承； 利用 Object.create 完成原型继承，</p>
<p>由此，解决了前面的所有问题:</p>
<ol>
<li>向父类传参</li>
<li>父类仅执行一次</li>
<li>支持继承属性</li>
<li>支持继承方法</li>
</ol>
<pre><code class="language-js">function Animal(category) {
  this.category = category;
  this.colors = [&quot;pink&quot;, &quot;green&quot;];
}
function Dog(name) {
  Animal.call(this, &quot;Dog&quot;);
}

Dog.prototype = Object.create(Animal);
Dog.prototype.constructor = Dog;

const dog1 = new Dog();
</code></pre>
<h2 id="7-class-继承">7. class 继承</h2>
<pre><code class="language-js">class Animal {
  constructor({ name, category }) {
    this.category = category;
    this.name = name;
  }
}
class Dog extends Animal {
  constructor(name) {
    super({ name, category: &quot;Dog&quot; });
    this.name = name;
  }
  bark() {
    console.log(this.name + &quot;: Woof!&quot;);
  }
}
const dog1 = new Dog(&quot;Max&quot;);
const dog2 = new Dog(&quot;Jell&quot;);
</code></pre>
</body></html>