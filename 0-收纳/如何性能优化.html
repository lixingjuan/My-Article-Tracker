<html><body><h1 id="性能优化">性能优化</h1>
<blockquote>
<p>请听题: 在整个开发全流程中，你认为可以做性能优化的地方？</p>
</blockquote>
<p>🧠 loading......</p>
<p>其实性能优化是贯穿我们开发的全流程: 代码编写, 脚手架打包, 网络</p>
<h2 id="代码编写">代码编写</h2>
<ul>
<li>使用框架提供的优化策略，例如 memo、useMemo、useCallback 等，减少不必要的渲染；</li>
<li>必须重复性的大量计算：比如有 5000 条格式，不同位置需要不同格式，尽量一次循环处理好；</li>
<li>必须重复创建对象：例如迭代过程中，数据量如果大，尽量修改的是同一个对象；</li>
<li>有些三方库的使用有很多要注意：比如日期格式化，我有遇到过 5000 条件数据，使用 moment 格式化日期 + 重复创建对象耗时 2s</li>
<li>懒加载包：代码编写过程，有些模块的引入是条件性，可以利用<code>import()</code>动态引入；</li>
<li>避免重流重绘：比如图片，给定宽高；合理使用 useLayoutEffect 和 useEffect，避免闪烁</li>
<li>dom 不要嵌套太深、减少不必要的 DOM</li>
<li>大量数据渲染使用虚拟 DOM</li>
<li>使用骨架屏，缓解用户焦虑</li>
</ul>
<h2 id="打包过程">打包过程</h2>
<p>利用 webpack 的配置</p>
<ul>
<li>代码压缩，减小代码提及：利用 <code>MiniCssExtractPlugin</code>、等 webpack plugin</li>
<li>React.lazy + 动态加载，减少每个页面访问加载的代码：在 react-router 中，对每个路由页面使用 <code>const Page1 = React.lazy(()=&gt; import(&#39;@/pages/Page1&#39;))</code></li>
<li>通过 webpack 配置缓存策略，cacheGroups.vendor, 通过文件 hash 值，让这些 js 文件能够缓存在浏览器中；</li>
<li>splitChunks 中配置，按需加载时最大并行请求数、入口处的最大并行请求数，拆分 chunk 的体积等；</li>
<li>Externals: 部分包使用 CDN</li>
</ul>
<h2 id="网络层面">网络层面</h2>
<ul>
<li>使用 webp 格式的图片</li>
<li>减少请求次数：小资源合并</li>
<li>使用 CDN</li>
<li>使用 HTTP/2: 因为 HTTP/2 引入了多路复用、头部压缩等特性，使得请求的建立、传输更快</li>
<li>开启 gzip: 通过修改 nginx 配置即可实现</li>
<li>使用懒加载技术, 例如图片，等内容即将进入视口再加载<ul>
<li>原生：图片 <code>&lt;img loading=&quot;lazy&quot; /&gt;</code></li>
<li>原生：iframe <code>&lt;iframe loading=&quot;lazy&quot; /&gt;</code></li>
<li>js 实现：三方库</li>
</ul>
</li>
</ul>
<h2 id="浏览器的渲染">浏览器的渲染</h2>
<ol>
<li>利用 prefetch/preload, 对资源进行预加载;</li>
<li>减少重流重绘;</li>
<li>减少空的 img 请求;</li>
</ol>
</body></html>