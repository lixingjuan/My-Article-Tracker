
## cookie的组成


通过Cookie 在客户端与服务器端进行交互，最终实现对用户身份的认证，cookie即是用户整个身份的代替，

cookie的属性如下：

<img src='/images/cookie的组成.jpg' />

1. **Name/value**:  设置Cookie 的名称以及相对应的只，对于认证cookie, Value包括Web服务器所提供的访问令牌
2. **Expires属**性: 设置cookie 的生存期，有两种存储类型的cookie
   1. 会话型，Expores属性缺省时，为会话性token, 仅保存在客户端的内存中，并在用户关闭浏览器时失效；
   2. 持久性cookie 会保存在用户的硬盘中，直至`生存期`到或者`用户主动注销`，该token才会失效；
3. **Path属性**：定义了Web站点上可以访问该Cookie的目录；
4. **Domain属性**：制定了可以访问该Cookie的web 站点或域，
5. **Secre属性**：指定是否使用HTTPS安全协议发送cookie. 使用HTTPS安全协议，可以保护Cookie 在浏览器和服务器传输的过程中不被窃取和篡改。
   1. 该方法也可用于web站点的身份鉴别，即在HTTPS的连接建立阶段，`浏览器`会检查web网站的`SSL证书` 的有效性，但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。
6. **HTTPOnly属性**：用于防治客户端脚本通过document.cookie属性访问cookie, 有助于保护Cookie 不被跨站脚本窃取或者篡改（但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头）



## cookie的安全性问题

cookie 可能存在的安全性问题：

1. cookie 被用户非法篡改，
   1. 如篡改其中的expire项目，可将cookie的有效期延长，
   2. 篡改path可以使用户能够访问服务器上不被授权的内容；
   3. 修改domain项，使用户能够访问不被授权的服务器从而获得合法用户的信息；
2. 被非法用户非法截获，然后在有效期内重放，则非法用户将享有合法用户的权益（例如CSFR）；
3. 若cookie 被服务器加密，非法用户通过强力攻击或者其他手段获得了相应的加密密钥，则非法用户可以伪造任何合法的cookie，从而可以访问合法用户的所有个性化信息甚至是账户信息；


保护措施：
1. 对cookie本身进行随机密钥加密，保证cookie本身的信息安全；
2. 防止非法用户非法截获后的重放，可以让用户对相关信息进行数字签名，加强有效性验证
3. 加入 MAC以进行完整性校验；

> MAC :（消息验证码，因为其安全性依赖于Hash函数，所以也称为带密钥的Hash函数）




## CSFR攻击

CSRF: 跨站请求伪造（Cross-Site Request Forgery）是指，攻击者可能利用网页中的恶意代码，强迫受害者浏览器向被攻击的Web站点发送伪造的请求，撺掇受害者的认证Cookie 等身份信息，从而假冒受害者对目标站点执行指定的操作

场景：

请求：`http://bank.example/withdraw?account=BoB&amount=1000000&for=BoB2` 的作用是账户BoB 向账号 BoB2 转账1000000元，通常情况下，服务器都会校验下token是否过期，若未过期，才允许该操作；

 Mary 也有这个银行的账号，所以他知道该接口可以进行转账操作，但是如果 Mary 直接发起请求，则需要校验 Mary 的登陆cookie, 于是   Mary 做一个广告网站， 里面又一个图片的标签是 `<img src='http://bank.example/withdraw?account=BoB&amount=1000000&for=Mary'/>` 若BoB进入了该网站，且刚刚登陆了银行账号，cookie仍未过期，则此请求就会发送成功，即操作 BoB转账1000000到Mary账户就会成功；


一些浏览器的情况

- FireFox, Opera 等浏览器使用单进程机制，多个窗口或者标签使用同一个进程，共享cookie等会话数据（？？是什么意思？具体指共享了哪些信息）
- IE则混用单进程和多进程模式，
  - 一个窗口中的多个标签，以及使用“ctrl+N”或者点击网页中的连接打开的新窗口使用统一进程，共享会话数据；
  - 只有直接运行IE可执行程序打开窗口时才会创建新的进程；
- Chrome虽然使用多进程机制，然而经测试发现，不同的窗口或者标签页之间仍会共享会话数据，除非使用隐身访问方式

因此，用户同时打开多个浏览器窗口或标签访问互联网资源时，就为CSRF攻击篡夺用户的会话创造了条件。另外，如果一个web站点提供持久化的Cookie,则CSRF将更直接、更容易；


## CSFR检测

最简单的方法是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。说明后端并未校验请求网址；

防御CSRF攻击三种策略
1. 验证 HTTP Referer 字段
2. 在请求地址中添加 token 并验证
3. 在 HTTP 头中自定义属性并验证



##  参考

1. [百度百科-cookie](https://baike.baidu.com/item/cookie/1119)

