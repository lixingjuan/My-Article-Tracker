/**
 * @题目描述
 * 小朋友出操，按学号从小到大排成一列;
 * 小明来迟了，请你给小明出个主意，让他尽快找到他应该排的位置。算法复杂度要求不高于nLog(n);
 * 学号为整数类型，队列规模<=10000;
 *
 * @输入描述
 * 1、第一行:输入已排成队列的小朋友的学号(正整数)，以”,”隔开
 * 例如: 93,95,97,100,102,123,155
 * 2、第二行:小明学号，如110;
 *
 * @输出描述
 * 输出一个数字，代表队列位置(从1开始),
 * 例如:
 * 6
 *
 * @示例
 * 输入：93,95,97,100,102,123,155
 * 输出：6
 */

const demo = (arr, target) => {
  let left = 0;
  let right = arr.length - 1;

  // 使用left <= right作为循环条件
  while (left <= right) {
    //!! 找中间位置的方法：Math.floor((开始+结束)/2)
    const midIndex = Math.floor((left + right) / 2);
    if (arr[midIndex] > target) {
      // 调整right的值，向左查找
      right = midIndex - 1;
    } else if (arr[midIndex] < target) {
      // 调整left的值，向右查找
      left = midIndex + 1;
    } else {
      // !! 应该不会有学号相同的情况
      return left + 1;
    }
  }

  // 如果没有直接找到，那么left将指向小明应该插入的位置
  // 位置从1开始计数，因此需要+1
  return left + 1;
};

// 测试用例1：小明的学号在队列中间的某个位置
console.log(demo([93, 95, 97, 100, 102, 123, 155], 110) === 6);

// 测试用例2：小明的学号比队列中所有学号都小
console.log(demo([93, 95, 97, 100, 102, 123, 155], 90) === 1);

// 测试用例3：小明的学号比队列中所有学号都大
console.log(demo([93, 95, 97, 100, 102, 123, 155], 160) === 8);

// 测试用例4：小明的学号恰好是队列最小学号
console.log(demo([93, 95, 97, 100, 102, 123, 155], 93) === 1);

// 测试用例5：小明的学号恰好是队列最大学号
console.log(demo([93, 95, 97, 100, 102, 123, 155], 155) === 7);

// 测试用例6：队列中只有一个学号，小明的学号更小
console.log(demo([100], 90) === 1);

// 测试用例7：队列中只有一个学号，小明的学号更大
console.log(demo([100], 110) === 2);

// 测试用例8：队列为空
console.log(demo([], 110) === 1);

// 测试用例9：小明的学号处于队列最小和次小之间
console.log(demo([93, 95, 97, 100, 102, 123, 155], 94) === 2);

// 测试用例10：队列中学号有较大间隔，小明的学号在间隔中
console.log(demo([93, 95, 150, 200], 120) === 3);
