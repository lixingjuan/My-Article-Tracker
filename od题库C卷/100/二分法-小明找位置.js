/**
 * @题目描述
 * 小朋友出操，按学号从小到大排成一列;
 * 小明来迟了，请你给小明出个主意，让他尽快找到他应该排的位置。算法复杂度要求不高于nLog(n);
 * 学号为整数类型，队列规模<=10000;
 *
 * @输入描述
 * 1、第一行:输入已排成队列的小朋友的学号(正整数)，以”,”隔开
 * 例如: 93,95,97,100,102,123,155
 * 2、第二行:小明学号，如110;
 *
 * @输出描述
 * 输出一个数字，代表队列位置(从1开始)例如:
 * 6
 */

const demo = (arr, target) => {
  let left = 0;
  let right = arr.length - 1;

  // 使用left <= right作为循环条件
  while (left <= right) {
    const middle = Math.floor((left + right) / 2);
    if (arr[middle] > target) {
      // 调整right的值，向左查找
      right = middle - 1;
    } else {
      // 调整left的值，向右查找
      left = middle + 1;
    }
  }

  // 如果没有直接找到，那么left将指向小明应该插入的位置
  return left + 1; // 位置从1开始计数，因此需要+1
};

console.log(demo([93, 95, 97, 100, 102, 123, 155], 110) === 6); // 应输出6
console.log(demo([93], 110) === 2); // 应输出6
console.log(demo([93], 10) === 1); // 应输出6

// 测试用例1：小明的学号在队列中间的某个位置
console.log(demo([93, 95, 97, 100, 102, 123, 155], 110)); // 应输出6

// 测试用例2：小明的学号比队列中所有学号都小
console.log(demo([93, 95, 97, 100, 102, 123, 155], 90)); // 应输出1

// 测试用例3：小明的学号比队列中所有学号都大
console.log(demo([93, 95, 97, 100, 102, 123, 155], 160)); // 应输出8

// 测试用例4：小明的学号恰好是队列最小学号
console.log(demo([93, 95, 97, 100, 102, 123, 155], 93)); // 应输出1

// 测试用例5：小明的学号恰好是队列最大学号
console.log(demo([93, 95, 97, 100, 102, 123, 155], 155)); // 应输出7

// 测试用例6：队列中只有一个学号，小明的学号更小
console.log(demo([100], 90)); // 应输出1

// 测试用例7：队列中只有一个学号，小明的学号更大
console.log(demo([100], 110)); // 应输出2

// 测试用例8：队列为空
console.log(demo([], 110)); // 应输出1

// 测试用例9：小明的学号处于队列最小和次小之间
console.log(demo([93, 95, 97, 100, 102, 123, 155], 94)); // 应输出2

// 测试用例10：队列中学号有较大间隔，小明的学号在间隔中
console.log(demo([93, 95, 150, 200], 120)); // 应输出3
