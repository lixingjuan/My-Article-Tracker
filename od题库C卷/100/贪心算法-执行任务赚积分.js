/**
 * @题目描述
 * 现有 N 个任务需要处理，同一时间只能处理一个任务，处理每个任务所需要的时间固定为 1。
 * 每个任务都有最晚处理时间限制和积分值，在最晚处理时间点之前处理完成任务才可获得对应的积分奖励。
 * 可用于处理任务的时间有限，请问在有限的时间内，可获得的最多积分。
 *
 * @输入描述
 * 第一行为一个数 N ，表示有 N 个任务（1 ≤ N ≤ 100 ）
 *
 * 第二行为一个数 T ，表示可用于处理任务的时间。（1 ≤ T ≤ 100）
 *
 * 接下来 N 行，每行两个空格分隔的整数（SLA 和 和 V ），SLA 表示任务的最晚处理时间，V 表示任务对应的积分。
 *
 * 1≤SLA≤100 , 0 ≤ V ≤ 100000
 *
 * @输出描述
 * 可获得的最多积分
 *
 * @示例1
 * 输入：
 * 4
 * 3
 * 1 2
 * 1 3
 * 1 4
 * 1 5
 *
 * 输出：
 * 5
 *
 * 说明：
 * 虽然有 3 个单位的时间用于处理任务，可是所有任务在时刻1之后都无效。 所以在第 1 个时间单位内，选择处理有 5 个积分的任务。1−3 时无任务处理。
 *
 * @示例2
 * 输入：
 * 4
 * 3
 * 1 2
 * 1 3
 * 1 4
 * 3 5
 *
 * 输出：
 * 9
 *
 * 说明：
 * 第 1 个时间单位内，处理任务3，获得 4 个积分
 * 第 2 个时间单位内，处理任务 4，获得 5 个积分
 * 第 3 个时间单位内，无任务可处理。
 * 共获得 9 个积分
 */

// function maxScore(N, T, tasks) {
//   // 先按照最后截止时间进行排序
//   const sorted = [...tasks].sort((a, b) => a[0] - b[0]);
// }

// // 示例测试
// const N1 = 4,
//   T1 = 3,
//   tasks1 = [
//     [1, 2],
//     [1, 3],
//     [1, 4],
//     [1, 5],
//   ];
// console.log(maxScore(N1, T1, tasks1)); // 输出: 5

// const N2 = 4,
//   T2 = 3,
//   tasks2 = [
//     [1, 2],
//     [1, 3],
//     [1, 4],
//     [3, 5],
//   ];
// console.log(maxScore(N2, T2, tasks2)); // 输出: 9
function maxScore(N, T, tasks) {
  // 初始化dp数组，dp[t]表示在时间t内可以获得的最大积分
  let dp = Array(T + 1).fill(0);

  // 遍历每个任务
  for (let i = 0; i < N; i++) {
    const [SLA, V] = tasks[i];
    // 从后向前遍历时间，确保每个任务只被考虑一次
    for (let t = SLA; t > 0; t--) {
      if (t <= SLA) {
        // 如果当前时间小于等于任务的最晚完成时间
        dp[t] = Math.max(dp[t], dp[t - 1] + V);
      }
    }
  }

  // dp[T]可能不是最大值，需要在dp数组中找到最大值
  return Math.max(...dp);
}

// 示例测试
const tasks1 = [
  [1, 2],
  [1, 3],
  [1, 4],
  [1, 5],
];
console.log(maxScore(4, 3, tasks1)); // 应该输出 5

const tasks2 = [
  [1, 2],
  [1, 3],
  [1, 4],
  [3, 5],
];
console.log(maxScore(4, 3, tasks2)); // 应该输出 9
