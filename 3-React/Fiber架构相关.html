<html><body><h1 id="fiber架构">fiber架构</h1>
<h2 id="推出版本">推出版本</h2>
<p>v16</p>
<h2 id="为什么提出fiber架构？">为什么提出fiber架构？</h2>
<p>是为了解决CPU的瓶颈。</p>
<p>而在React16之前的架构设计，包括两层：</p>
<ol>
<li>Reconciler</li>
<li>Renderer</li>
</ol>
<p>在Stack Reconciler中，挂载和更新子组件，都会递归更新子组件，递归一旦开始，就无法停止，如果子组件过多，js执行时间就会过长，就会导致页面卡顿的效果。</p>
<p>而浏览器的渲染频率为60HZ, 也就是一帧16.6ms, 而在这16.6ms内，浏览器需要做三件事：</p>
<pre><code>js执行 =&gt; 页面绘制 =&gt; 渲染
</code></pre>
<p>而浏览器中，GUI线程和js线程是互斥的，所以如果js的执行时间超过16.6ms的话，GUI线程就没有时间执行页面绘制和渲染，用户体验就会有明显的卡顿、掉帧。</p>
<h2 id="fiber架构目标">fiber架构目标</h2>
<p>react在16提出了fiber架构，主要解决四个问题：</p>
<ol>
<li>事件执行可中断</li>
<li>中断之后可以恢复工作；</li>
<li>任务分配优先级；</li>
<li>抛弃不必要执行的任务；</li>
</ol>
<h2 id="fiber实现思路">fiber实现思路</h2>
<p>Fiber把整个渲染更过程划分为多个小的任务单元，也就是fiber, 每个fiber都是一个执行单元.</p>
<p>React的fiber架构包含三层，分别是</p>
<ul>
<li>Scheduler: 调度器；</li>
<li>Reconciler:  协调器；由 Stack Reconciler 变成 Fiber Reconciler</li>
<li>Renderer: 渲染器；</li>
</ul>
<h3 id="事件可中断">事件可中断</h3>
<p>每次fiber执行前都先判断是否应该继续执行，判断条件是:</p>
<ol>
<li>是否有更高优先级的fiber出现，如果有，则先执行该高优先级fiber, 完成后再回来执行当前fiber;</li>
<li>当前帧是否剩余时间, 如果没有， 则中断执行，则将控制权交给主线程；<ol>
<li>判断是否剩余执行时间，使用 <code>requestAnimationFrame</code> 重新实现了requestIdleCallback，即Scheduler（调度器），未直接使用 <code>requestIdleCallback</code>, 是由于 浏览器兼容性；</li>
</ol>
</li>
</ol>
<h3 id="事件可恢复">事件可恢复</h3>
<p><code>利用链式结构实现事件可恢复的</code></p>
<p>从编码的角度看，fiber是reat内部实现的一套数据结构，上面记录了非常多属性，其中有三个属性</p>
<pre><code class="language-js">this.return = null;              // 指向父级fiber
this.child = null;               // 指向子级fiber
this.sibling = null;             // 右边第一个兄弟
</code></pre>
<ul>
<li>这三个属性将一个个的fiber节点组成一个大的fiber tree, 可以根据一个节点找到所有关联节点，</li>
<li>当任务准备挂起时，通过一个全局变量记住当前 <code>任务节点</code>，</li>
<li>任务恢复的时候，通过这个全局变量来找到下一个要执行的任务，</li>
<li>就这样一直处理下去，直到没有要处理的节点返回。</li>
</ul>
<h3 id="优先级模型">优先级模型</h3>
<h4 id="expirationtime">expirationTime</h4>
<p>react 通过算法，给所有的任务分配过期时间（expirationTime），也就是：</p>
<ul>
<li><code>过期时间越短，优先级越高</code></li>
<li>某个任务的过期时间比当前时间短，表示已经过期，需要立即执行（可能会发生中断）</li>
<li>随着时间推移，当前时间越接近过期时间，优先级变高</li>
</ul>
<blockquote>
<p>为什么不使用generator来控制任务的中断和执行?
因为generator有上下文依赖关系，无法插入高优先级任务；</p>
</blockquote>
<p>react 17.0-rc 优先级模型改为了lanes</p>
<h4 id="lanes">lanes</h4>
<p><code>lanes</code> 解决 <code>expirationTime</code> 模型导致的低优先级任务长时间等待的问题</p>
<p>对优先级进行了更细粒度的划分</p>
<h3 id="抛弃不必要执行的任务">抛弃不必要执行的任务</h3>
<p>重新构建在内存中workInProgressFiberTree</p>
<h2 id="fiber更新dom过程">fiber更新dom过程</h2>
<p>fiber架构 采用了双缓冲树架构</p>
<p>在react中同时有两颗fiber树：</p>
<ul>
<li>当前屏幕上渲染的叫做 <code>currentFiber</code>，</li>
<li>正在内存中构建的叫做 <code>workInProgressFiber</code></li>
</ul>
<p>他们通过alternate属性连接</p>
<pre><code class="language-js">currentFiber.alternate === workInProgressFiber;
workInProgressFiber.alternate === currentFiber;
</code></pre>
<p>当 <code>workInProgress Fiber</code> 构建完成后交给 <code>Renderer</code> 渲染到屏幕后，应用根节点的 <code>current指针</code>指向 <code>workInProgress Fiber</code>, 此时 <code>workInProgress Fiber</code> 就变成 <code>currentFiber</code></p>
<p>每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。</p>
</body></html>