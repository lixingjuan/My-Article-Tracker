# EventLoop

> 函数调用栈、事件队列、内存的视图表现

<img src="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg" alt="">




## 你了解浏览器的事件循环么？

任务分为宏任务，微任务


## 为什么js在浏览器中有事件循环的机制？

因为JavaScript主要工作在浏览器，而浏览器的主要工作是实现用户交互，效果呈现，

如果一个线程在一个DOM节点修改内容，另一个线程删除了该DOM节点，此时就会引起**冲突**

于是js采用单线程的运行机制

> 备注: 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript 创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。
所以该标准并没有改变js单线程的本质;



## 两种任务？

宏任务: 整体代码，setTimeout, setInterval, I/O事件
微任务: new Promise().then, MutationObserver


## 为什么分为宏任务，微任务？

> 为了提高硬件利用率;

单线程就意味着所有任务都需要排队，前一个任务执行完，才会执行下一个任务。如果前一个任务耗时很长，后一个任务就需要一直等待;

这种机制导致很多时候，CPU都是空闲的。因为I/O设备很慢（比如网络请求）, CPU会一直等待结果出来，再往下执行计算;

这样造成CPU大量时间都是等待过程，由于js的解析机制是从上向下按顺序解析，如果网络卡顿，就会堵塞页面渲染；

于是js语言的设计者意识到，这时主线程完全可以不管IO设备，挂起等待中的任务，先运行排在后面的任务，等IO设备返回了结果，再回过头执行挂起的任务。

所以提出，将所有的任务分为两种：**同步任务** 和 **异步任务**；

- 同步任务指，在**主线程**上排队执行的任务，只有当前一个任务执行完毕，才会执行下一个任务；
- 异步任务指，**不进入主线程**，而进入任务队列（task queue）的任务, 只有任务队列通知主线程异步任务可以执行了，该异步任务才会进入主线程；



## 运行机制？

1. 所有**同步任务都在主线程**上执行，形成一个执行栈；
2. 主线程之外，还存在一个 “任务队列”。 只要异步任务有了结果，就在任务队列放置一个事件；
3. 一旦执行栈的同步任务执行完毕，主线程就会读取 “任务队列” ，异步任务就结束等待状态，进入执行站，开始执行；
4. 循环以上三个步骤；


主线程从 “任务队列” 读取任务的这个过程是源源不断的，所有这个过程称为event Loop


<img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png">





## 1.3. 事件和回调函数

"任务队列"是一个事件的队列（也可以理解成消息的队列）, 即webAPIS 产生的事件（DOM，ajax, setTimeout），IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件。

"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。

所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。





## 1.5. 定时器

setTimeout()只是将事件插入到“任务队列”，必须等到当前执行栈代码执行完毕，才会去执行他指定的回调函数，如果当前代码耗时特别久，那setTimeout()的回调函数可能要等很久，所以并不能保证回调函数一定会在其指定的时间执行。




# 2. Node.js

## 2.1. Node的执行机制

Node.js 也是单线程的Event Loop, 但是他的执行机制和js不同:
1. v8解析js脚本；
2. 解析后的代码，调用Node API；
3. libuv负责Node API的执行, 然后 **将不同的任务分给不同线程** ，形成一个eventLoop, 以异步的方式将任务的执行结果返回给V8引擎；
4. v8引擎将结果返回给用户；


## 2.2. “任务队列”相关方法

**process.nextTick:**
在当前“执行栈”之后，下一次 Eventloop (主线程读取“任务队列”) 发生之前触发回调函数，也就是他指定的任务总是发生在所有异步任务发生之前；

**setImmediate:**
在当前“任务队列” 尾部添加事件，也就是会说他指定的事件在下一个 Eventloop 发生，作用类似setTimeout(fn, 0)；



# 3. 相关参考文章

1. [阮一峰-JavaScript 运行机制详解：再谈Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)




