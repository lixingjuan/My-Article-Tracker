# 异步函数

## await

因为异步函数主要针对不会发上完成的任务，所以自然需要一种暂停和恢复执行的能力，使用await 关键字可以暂停异步函数代码的执行，等待期约的解决。

**以下两种写法是相同的**

Promise

```js
let p = new Promise((resolve, reject)=>setTimeout(console.log, 1000, 3))
p.then(console.log)
```


异步函数

```js
async function foo(params) {
  let p = new Promise((resolve, reject)=>setTimeout(console.log, 1000, 3))
  console.log(await p);
}
foo()
```


> await 关键字的原理: await 关键字会暂停执行异步函数后面的代码，让出javascript 的执行线程。这个行为与生成器函数中的 yield 关键字是一样的。await 关键字同样是尝试解包对象的值，然后将这个值传给表达式， 再异步恢复异步函数的执行。


## await与异步函数的返回

await 期待(实际上并不要求)一个实现thenable接口的对象，但常规的值也可以。如果是一个实现thenable接口的对象，则这个对象会被await 默认解包; 如果不是，则这个值会被当作已经解决的期约。



等待一个原始值

```js
const foo = async () => {
  const a = await "foa";
  console.log("a", a);
};
foo();
// a foa
```


**等待一个实现了thenable接口的对象**

```js
const foo1 = async () => {
  const thenable = {
    then(callback) {
      callback("baz");
    },
  };
  const a = await thenable;
  console.log("a", a);
};

foo1();
// a baz
```


等待一个期约

```js
const foo = async () => {
  const a = await Promise.resolve("hello");
  console.log("a", a);
};

foo();
// a hello
```



等待会抛出错误的同步操作，会返回拒绝的期约, 抛出未捕获错误

```js
const foo = async () => {
  console.log(1);
  await (() => {
    throw "3";
  })();
};

foo()
console.log(2);
// 1
// 2
// (node:8597) UnhandledPromiseRejectionWarning: 3
```

```js
const foo = async () => {
  console.log(1);
  await (() => {
    throw "3";
  })();
};

foo().catch(console.log);
console.log(2);
// 1
// 2
// 3
```


reject 后面的代码不会执行

```js
const foo = async () => {
  console.log(1);
  await Promise.reject(3);
  console.log(4) // 这里不会执行
};

foo().catch(console.log);
console.log(2);

```




## 练习题

以下代码的执行顺序是什么？

1. 考察是否知道await后代码的执行顺序


```js
function foo(){
  awiat console.log(1);
}
foo()
console.log(2)
```


2. 考察是否知道Promise.reject后的代码不执行

```js
const foo = async () => {
  console.log(1);
  await Promise.reject(3);
  console.log(4) // 这里不会执行
};

foo().catch(console.log);
console.log(2);
```