9.  原型链的理解：
    1.  我理解，所有的对象都有一个 `prototype` 属性，指向他的原型，原型都有个costructor属性指向该对象;
    2.  我们可以通过new操作符创建该对象的实例，创建的实例拥有一个 `__proto__` 指针，指向其构造函数的原型对象;
    3.  实例可以继承其原型对象的所有可继承属性和方法;
    4.  原型链，当我们在一个对象上查找某属性的时候，若该对象有，就直接返回，若没有，则沿着原型链继续向上查到，查找到 OBject.prototype 即停止;
    5.  几乎所有的原型对象都是位于原型链顶端的 `Object` 的实例;



## 原型和原型链

> JavaScript的原型存在诸多矛盾，他的某些复杂的语法看起来像是基于类的语言，这些语法问题掩盖了他的原型机制。他不直接让对象从其他对象继承，反而插入了一个多余的简介曾， 通过构造函数产生对象
> 当一个函数对象被创建时， Function构造器产生的函数对象会运行类似这样的一些代码

```javascript
this.prototype = { constructor: this}
```


新函数对象会被赋予一个`prototype`属性，该属性的值是一个包含`constructor`属性且属性值是该新函数的对象。 这个`prototype`对象是用来存放**继承特征**的地方。
因为JavaScript没有提供一种方法用来确定哪个函数是存放继承特征的地方，所以每个函数都会得到一个prototype对象，constructor对象没什么用，重要是的`prototype`对象。



`prototype`属性指向函数的原型对象。默认情况下，所有原型对象都会自动获得一个`construct`（构造函数）属性，这个属性包含一个指向`prototype`属性所在函数的指针，而通过这个构造函数，我们还可以为函数原型添加其他属性和方法。




1. 我们创建的每个函数都有一个 prototype 属性，这个属性是一个指针，指向一个对象
2. 指向的这个对象的用途呢，是 ==包含可以由特定类型的所有实例共享的属性和方法==；
3. 字面意思：prototype 就是通过调用构造函数创建的那个对象实例的原型对象；
4. 使用对象原型的好处：可以让他的所有实例，共享他包含的属性和方法；
5. 换句话说，不必在构造函数中定义对象实例的信息，而是可以直接将这些实例添加到原型对象中；
6. 只要新建一个函数，都会根据一组特定的规则为函数创建prototype属性，这个属性指向函数的原型对象；
7. 在默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针；
8. 创建了自定义的构造函数后，其原型对象默认只会取得constructor属性，至于其他方法，都是从Object继承来的；
9. 当调用构造函数创建第一个实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象
  - ECMA-262管那个指针叫[[prototype]]，
  - 在脚本中没有标准的方式访问，但是在 Forefox, Safari 和Chrome在每个对象上都支持一个属性__proto__ ， 去访问该实例的构造函数的原型；
  - 而在其他实现中，这个属性对脚本是完全不可见的；
  - 注意：这个连接，存在于‘实例’ 和 ‘ 构造函数’ 的原型之间，而不是 ’实例‘ 和 ’构造函数‘ 之间


```javascript
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    alert(this.name);
  };
}

const person1 = new Person();
const person2 = new Person();
```

<img src="/Blog/images/原型链表示图.png" title="原型链表示图" width="70%" height="50%">





## 确定原型和实例之间的关系

1. instanceof

```javascript
const Person = function() {
  this.name = "lixingjuan";
};
const person1 = new Person();
person1 instanceof Person; // true
```


2. isPrototypeOf()方法

```javascript
const Person = function() {
  this.name = "lixingjuan";
};
const person1 = new Person();
Person.prototype.isPrototypeOf(person1); // true
```


## 参考文章
1. 《JavaScript语言精粹 - 第五章 继承-伪类》