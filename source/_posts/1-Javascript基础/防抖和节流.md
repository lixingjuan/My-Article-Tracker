# 防抖和节流

=> [测试地址](https://jsbin.com/rebucuputi/edit?html,css,output)



## 防抖

高频事件在规定的事件只执行一次，如规定的时间内再次触发，则重新计算时间



```javascript
/**
 * @des 防抖
 * @param {Function} func 要进行防抖的数据
 * @return:
 */
function debounce(func, wait = 1000) {
  let timeout;

  return function(event) {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.call(this, event);
    }, wait);
  };
}
```






## 节流

高频时间在规定的时间内不管触发事件多少次，都只定时去执行一次

1. 节流1:时间戳

特点
- 第一次触发即立即执行
- 最后一次触发离开后不会再执行

实现思路：设置一个时间戳，调用函数的时候，如果当前的时间戳减去设置的时间错，大于wait,则执行函数；若小于则不执行；

```javascript
function throttle(func, wait = 1000) {
  let context, args;
  let previous = 0;

  return function() {
    var now = +new Date();
    context = this;
    args = arguments;
    if (now - previous > wait) {
      func.apply(context, args);
      previous = now;
    }
  };
}
```

2. 节流2:定时器
- 特点
  - 第一次触发不执行
  - 最后一次触发离开后仍执行执行
- 实现思路：触发事件的时候，设置一个定时器，再次触发的时候，若定时器存在，则不执行；知道定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器；

```javascript
function throttle(func, wait = 1000) {
  let context, args;
  let timeout;

  return function() {
    context = this;
    args = arguments;
    if (!timeout) {
      timeout = setTimeout(function() {
        timeout = null;
        func.apply(context, args);
      }, wait);
    }
  };
}
```

### 节流3:结合版

特点
- 第一次触发即立即执行
- 最后一次触发离开后仍执行执行

```javascript
function throttle(func, wait) {
    var timeout, context, args, result;
    var previous = 0;

    var later = function() {
        previous = +new Date();
        timeout = null;
        func.apply(context, args)
    };

    var throttled = function() {
        var now = +new Date();
        //下次触发 func 剩余的时间
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
         // 如果没有剩余的时间了或者你改了系统时间
        if (remaining <= 0 || remaining > wait) {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            previous = now;
            func.apply(context, args);
        } else if (!timeout) {
            timeout = setTimeout(later, remaining);
        }
    };
    return throttled;
}
```

- 参考文章：https://github.com/mqyqingfeng/Blog/issues/22
- 参考文章：https://github.com/mqyqingfeng/Blog/issues/26






<style>
  #demo-wrapper {
    /* position: absolute: */
    /* top: 30px; */
  }
  div.content {
    width: 100%;
    height: 200px;
    line-height: 200px;
    text-align: center;
    color: #fff;
    font-size: 30px;
    margin-top: 30px;
  }
  #debounceDiv {
    background-color: #f5c160;
  }
  #throttleDiv {
    background-color: #e4980d;
  }
</style>


<div id="demo-wrapper">






   <h3>防抖测试块</h3>
    <p>高频事件在规定的时间内仅执行一次，若规定时间内再次触发，则重新计算时间</p>
    <div class="content" id="debounceDiv"></div>
    <h3>节流测试块</h3>
    <p>高频事件在规定的时间内不管触发多少次，都只触发一次</p>
    <div class="content" id="throttleDiv"></div>

    <script>
      let count = 1;
      const debounceDiv = document.getElementById("debounceDiv");

      function getUserAction() {
        debounceDiv.innerHTML = count++;
      }

      function debounce(func, wait = 1000) {
        let timeout;

        return function(event) {
          console.log("清除计时器");
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            func.call(this, event);
          }, wait);
        };
      }

      debounceDiv.onmousemove = debounce(getUserAction);
    </script>

    <script>
      let throttleCount = 1;
      const throttleDiv = document.getElementById("throttleDiv");

      function getUserAction() {
        throttleDiv.innerHTML = throttleCount++;
      }

      function throttle(func, wait = 1000) {
        let context, args;
        let previous = 0;

        return function() {
          var now = +new Date();
          context = this;
          args = arguments;
          if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
          }
        };
      }

      throttleDiv.onmousemove = throttle(getUserAction);
    </script>
</div>